<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Opiyo Okach</title>

    <!-- bootstrap -->
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/css/bootstrap.min.css" integrity="sha384-MCw98/SFnGE8fJT3GXwEOngsV7Zt27NXFoaoApmYm81iuXoPkFOJwJ8ERdknLPMO" crossorigin="anonymous">
    <link rel="stylesheet" href="style.css">
</head>
<body>

    <div id="overlay" class="container-fluid">
      <div class="row">
          <div class="col-12 d-flex align-items-center justify-content-center">
              <div>
                  <h1>Opiyo Okach Project</h1>
                  <h4>Instructions for computer</h4>
                  <p>Use your mouse to engage with the project</p>
                  <ul>
                      <li>click and drag with the mouse to orbit around the network</li>
                      <li>zoom in and out to move</li>
                      <li>click on the words to open the different chapters of the project</li>
                  </ul>
                  <h4>Instructions for touch screen</h4>
                  <ul>
                      <li>tag and drag to orbit around the network</li>
                      <li>pinch to zoom in and out</li>
                      <li>tap on words to open different chapters of the project</li>
                  </ul>
              </div>
          </div>
          <div class="col-12 text-center my-5">
              <button id="startButton" class="btn btn-light btn-lg">Play</button>
          </div>
      </div>
  </div>

    <div class="three-js-container">
      <canvas id="c"></canvas>
        <div class="labels">
        </div>
    </div>
    
    <audio loop id="music" preload="auto" style="display: none">
      <source src="assets/bensound-anewbeginning.ogg" type="audio/ogg">
    </audio>

    <script src="https://code.jquery.com/jquery-3.3.1.slim.min.js" integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.3/umd/popper.min.js" integrity="sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49" crossorigin="anonymous"></script>
    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/js/bootstrap.min.js" integrity="sha384-ChfqqxuZUCnJSK3+MXmPNIyE6ZbWh2IMqE241rYiqJxyMiZ6OW/JmZQ5stwEULTy" crossorigin="anonymous"></script>
    <!-- <script src="globals.js"></script> -->

    <script type="module">

import * as THREE from 'https://threejsfundamentals.org/threejs/resources/threejs/r119/build/three.module.js';
import {OrbitControls} from 'https://threejsfundamentals.org/threejs/resources/threejs/r119/examples/jsm/controls/OrbitControls.js';
// import {GUI} from 'https://threejsfundamentals.org/threejs/../3rdparty/dat.gui.module.js';

console.log('changed sound 1 - directional cone');

const makeInstance = (scene, geometry, x, y, z) => {
	const material = new THREE.MeshPhongMaterial({color: 0x00ff00});

	const cube = new THREE.Mesh(geometry, material);
	scene.add(cube);

	cube.position.set(  x, y, z );
	cube.material.transparent = true ;
	cube.material.opacity = 0;

	return cube;
};

// add a box
const boxWidth = 20;
const boxHeight = 10;
const boxDepth = 1;
const geometryBox = new THREE.BoxGeometry(boxWidth, boxHeight, boxDepth);

function main() {

  // camera and canvas
  const canvas = document.querySelector('#c');
  const renderer = new THREE.WebGLRenderer({canvas});

  const fov = 45;
  const aspect = 2;  // the canvas default
  const near = 0.1;
  const far = 100;
  const camera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 1, 10000 );
  camera.position.set( 0, 25, 200 );

  // update camera
  function updateCamera() {
    camera.updateProjectionMatrix();
  }

  // orbit controls
  const controls = new OrbitControls(camera, canvas);
  controls.target.set(0, 5, 0);
  controls.update();

  // new scene
  const scene = new THREE.Scene();
  scene.background = new THREE.Color('black');
  scene.fog = new THREE.FogExp2( 0x000000, 0.0025 );

  // add light
  {
    const color = 0xFFFFFF;
    const intensity = 1;
    const light = new THREE.DirectionalLight(color, intensity);
    light.position.set(0, 0.5, 1);
    light.target.position.set(0, 0, 0);
    scene.add(light);
    scene.add(light.target);
  }

// bring in audio
  const audioElems = () => {
    // bring in audio listener
      const listener = new THREE.AudioListener();
      camera.add( listener );

      // sound spheres
      const square = new THREE.BoxGeometry(30, 30, 30);

      const material1 = new THREE.MeshBasicMaterial( { color: 0xffaa00 } );
      const material2 = new THREE.MeshBasicMaterial( { color: 0xff2200 } );
      const material3 = new THREE.MeshBasicMaterial( { color: 0x6622aa } );

      // sound spheres

      const audioLoader = new THREE.AudioLoader();

      const mesh1 = new THREE.Mesh( square, material1 );
      mesh1.position.set( - 250, 30, 0 );
      scene.add( mesh1 );

      var audioElement = document.getElementById( 'music' );
      audioElement.play();

      const sound1 = new THREE.PositionalAudio( listener );
      
      sound1.setMediaElementSource(audioElement );
      sound1.setLoop()
      sound1.setRefDistance( 20 );
      sound1.setDirectionalCone( 180, 230, 0.1 );
      mesh1.add( sound1 );

      //

      // const mesh2 = new THREE.Mesh( square, material2 );
      // mesh2.position.set( 250, 30, 0 );
      // scene.add( mesh2 );

      // const sound2 = new THREE.PositionalAudio( listener );
      // audioLoader.load( 'assets/bensound-creativeminds.ogg', function ( buffer ) {

      //   sound2.setLoop()
      //   sound2.setBuffer( buffer );
      //   sound2.setRefDistance( 20 );
      //   sound2.play();

      // } );
      // mesh2.add( sound2 );

      //

      // const mesh3 = new THREE.Mesh( square, material3 );
      // mesh3.position.set(  0, 30, - 250 );
      // scene.add( mesh3 );

      // const sound3 = new THREE.PositionalAudio( listener );
      // audioLoader.load( 'assets/bensound-ukulele.ogg', function ( buffer ) {

      //   sound3.setLoop();
      //   sound3.setBuffer( buffer );
      //   sound3.setRefDistance( 20 );
      //   sound3.play();

      // } );
      // mesh3.add( sound3 );  

      // analysers

      const analyser1 = new THREE.AudioAnalyser( sound1, 32 );
      // const analyser2 = new THREE.AudioAnalyser( sound2, 32 );
      // const analyser3 = new THREE.AudioAnalyser( sound3, 32 );

}
  
  audioElems();

// particle related variables
  let particlesData = [];
  let positions, colors;
  let particles;
  let pointCloud;
  let particlePositions;
  let linesMesh;

  const maxParticleCount = 100;
  const particleCount = 50;
  const r = 200;
  const rHalf = r / 2;

  var particleXYZ = [];
  let cubes = []; 

  let effectController = {
      showDots: true,
      showLines: true,
      minDistance: 150,
      limitConnections: false,
      maxConnections: 20,
      particleCount: 500
  };


  // add cubes to be repositioned later
const addInteractives = () => {
  cubes = [
			makeInstance(scene, geometryBox, 0, 0, 0), 
			makeInstance(scene, geometryBox, 0, 0, 0), 
			makeInstance(scene, geometryBox, 0, 0, 0), 
			makeInstance(scene, geometryBox, 0, 0, 0), 
			makeInstance(scene, geometryBox, 0, 0, 0), 
			makeInstance(scene, geometryBox, 0, 0, 0)
		]
}

addInteractives();


  // create cloud group
  const cloudGroup = new THREE.Group();
  scene.add( cloudGroup );

  const segments = maxParticleCount * maxParticleCount;

  positions = new Float32Array( segments * 3 );
  colors = new Float32Array( segments * 3 );

  var pMaterial = new THREE.PointsMaterial( {
      color: 0xFFFFFF,
      size: 4,
      blending: THREE.AdditiveBlending,
      transparent: true,
      sizeAttenuation: false
  } );

  particles = new THREE.BufferGeometry();
  particlePositions = new Float32Array( maxParticleCount * 3 );

		for ( var i = 0; i < maxParticleCount; i ++ ) {

			var x = Math.random() * r - r / 2;
			var y = Math.random() * r - r / 2;
			var z = Math.random() * r - r / 2;

			particlePositions[ i * 3 ] = x;
			particlePositions[ i * 3 + 1 ] = y;
			particlePositions[ i * 3 + 2 ] = z;

			

			// add it to the geometry
			particlesData.push( {
				velocity: new THREE.Vector3( - 1 + Math.random() * 2, - 1 + Math.random() * 1, - 1 + Math.random() * 2 ),
				numConnections: 0
			} );
		}


		particles.setDrawRange( 0, particleCount );
		particles.setAttribute( 'position', new THREE.BufferAttribute( particlePositions, 3 ).setUsage( THREE.DynamicDrawUsage ) );
		

		// create the particle system
		pointCloud = new THREE.Points( particles, pMaterial );
		cloudGroup.add( pointCloud );

		var geometry = new THREE.BufferGeometry();

		geometry.setAttribute( 'position', new THREE.BufferAttribute( positions, 3 ).setUsage( THREE.DynamicDrawUsage ) );
		geometry.setAttribute( 'color', new THREE.BufferAttribute( colors, 3 ).setUsage( THREE.DynamicDrawUsage ) );

		geometry.computeBoundingSphere();

		geometry.setDrawRange( 0, 0 );


		var material = new THREE.LineBasicMaterial( {
			vertexColors: true,
			blending: THREE.AdditiveBlending,
			transparent: true
		} );

		linesMesh = new THREE.LineSegments( geometry, material );
		cloudGroup.add( linesMesh );
    
    function animateBuffer() {
			      let k = 0;
          var vertexpos = 0;
          var colorpos = 0;
          var numConnected = 0;
          
          for ( var i = 0; i < particleCount; i ++ )
            particlesData[ i ].numConnections = 0;

          for ( var i = 0; i < particleCount; i ++ ) {

            // get the particle
            var particleData = particlesData[ i ];

            particlePositions[ i * 3 ] += particleData.velocity.x/7;
            particlePositions[ i * 3 + 1 ] += particleData.velocity.y/7;
            particlePositions[ i * 3 + 2 ] += particleData.velocity.z/7;

            // calculate where cubes are going to be
            let remainder = Math.floor(particleCount / 6);
            if(i % remainder === 0 && k < 6){
            	particleXYZ[k] = {
            		x: particlePositions[ i * 3 ], 
            		y: particlePositions[ i * 3 + 1 ], 
            		z: particlePositions[ i * 3 + 2 ]
            	};
            	k++
            }

            

            if ( particlePositions[ i * 3 + 1 ] < - rHalf || particlePositions[ i * 3 + 1 ] > rHalf )
              particleData.velocity.y = - particleData.velocity.y;

            if ( particlePositions[ i * 3 ] < - rHalf || particlePositions[ i * 3 ] > rHalf )
              particleData.velocity.x = - particleData.velocity.x;

            if ( particlePositions[ i * 3 + 2 ] < - rHalf || particlePositions[ i * 3 + 2 ] > rHalf )
              particleData.velocity.z = - particleData.velocity.z;

            if ( effectController.limitConnections && particleData.numConnections >= effectController.maxConnections )
              continue;

            
            // Check collision
            for ( var j = i + 1; j < particleCount; j ++ ) {

              var particleDataB = particlesData[ j ];
              if ( effectController.limitConnections && particleDataB.numConnections >= effectController.maxConnections )
                continue;

              var dx = particlePositions[ i * 3 ] - particlePositions[ j * 3 ];
              var dy = particlePositions[ i * 3 + 1 ] - particlePositions[ j * 3 + 1 ];
              var dz = particlePositions[ i * 3 + 2 ] - particlePositions[ j * 3 + 2 ];
              var dist = Math.sqrt( dx * dx + dy * dy + dz * dz );

              
              if ( dist < effectController.minDistance ) {

                particleData.numConnections ++;
                particleDataB.numConnections ++;

                var alpha = 1.0 - dist / effectController.minDistance;

                positions[ vertexpos ++ ] = particlePositions[ i * 3 ];
                positions[ vertexpos ++ ] = particlePositions[ i * 3 + 1 ];
                positions[ vertexpos ++ ] = particlePositions[ i * 3 + 2 ];

                positions[ vertexpos ++ ] = particlePositions[ j * 3 ];
                positions[ vertexpos ++ ] = particlePositions[ j * 3 + 1 ];
                positions[ vertexpos ++ ] = particlePositions[ j * 3 + 2 ];

                colors[ colorpos ++ ] = alpha;
                colors[ colorpos ++ ] = alpha;
                colors[ colorpos ++ ] = alpha;

                colors[ colorpos ++ ] = alpha;
                colors[ colorpos ++ ] = alpha;
                colors[ colorpos ++ ] = alpha;

                numConnected ++;

              }

			}

		}


		linesMesh.geometry.setDrawRange( 0, numConnected * 2 );
		linesMesh.geometry.attributes.position.needsUpdate = true;
		linesMesh.geometry.attributes.color.needsUpdate = true;

    pointCloud.geometry.attributes.position.needsUpdate = true;
    
    cubes.forEach((cube, index) => {
			cube.position.set(particleXYZ[index].x, particleXYZ[index].y, particleXYZ[index].z);
			cube.rotation.y = Math.atan2( ( camera.position.x - cube.position.x ), ( camera.position.z - cube.position.z ) );
		});

		}


  function resizeRendererToDisplaySize(renderer) {
    const canvas = renderer.domElement;
    const width = canvas.clientWidth;
    const height = canvas.clientHeight;
    const needResize = canvas.width !== width || canvas.height !== height;
    if (needResize) {
      renderer.setSize(width, height, false);
    }
    return needResize;
  }

  function render() {

    if (resizeRendererToDisplaySize(renderer)) {
      const canvas = renderer.domElement;
      camera.aspect = canvas.clientWidth / canvas.clientHeight;
      camera.updateProjectionMatrix();
    }

    renderer.render(scene, camera);

    requestAnimationFrame(render);
    requestAnimationFrame(animateBuffer);
  }

  requestAnimationFrame(render);
}

const beginBtn = document.querySelector('#startButton');
const overlay = document.querySelector('#overlay');


beginBtn.addEventListener('click', () => {
  overlay.style.display = 'none';
  main();
})

    </script>

</body>
</html>